server cgnat {
    listen {
        ipaddr = *
    #	ipv6addr = ::
        port = 0
        type = acct
    #	interface = eth0
    #	clients = per_socket_clients

        limit {
            #  The number of packets received can be rate limited via the
            #  "max_pps" configuration item.  When it is set, the server
            #  tracks the total number of packets received in the previous
            #  second.  If the count is greater than "max_pps", then the
            #  new packet is silently discarded.  This helps the server
            #  deal with overload situations.
            #
            #  The packets/s counter is tracked in a sliding window.  This
            #  means that the pps calculation is done for the second
            #  before the current packet was received.  NOT for the current
            #  wall-clock second, and NOT for the previous wall-clock second.
            #
            #  Useful values are 0 (no limit), or 100 to 10000.
            #  Values lower than 100 will likely cause the server to ignore
            #  normal traffic.  Few systems are capable of handling more than
            #  10K packets/s.
            #
            #  It is most useful for accounting systems.  Set it to 50%
            #  more than the normal accounting load, and you can be sure that
            #  the server will never get overloaded
            #
    #		max_pps = 0

            # Only for "proto = tcp". These are ignored for "udp" sockets.
            #
    #		idle_timeout = 0
    #		lifetime = 0
    #		max_connections = 0
        }
    }

    #
    #  Pre-accounting.  Decide which accounting type to use.
    #
    preacct {
        preprocess

        #
        #  Merge Acct-[Input|Output]-Gigawords and Acct-[Input-Output]-Octets
        #  into a single 64bit counter Acct-[Input|Output]-Octets64.
        #
    #	acct_counters64

        #
        #  Session start times are *implied* in RADIUS.
        #  The NAS never sends a "start time".  Instead, it sends
        #  a start packet, *possibly* with an Acct-Delay-Time.
        #  The server is supposed to conclude that the start time
        #  was "Acct-Delay-Time" seconds in the past.
        #
        #  The code below creates an explicit start time, which can
        #  then be used in other modules.  It will be *mostly* correct.
        #  Any errors are due to the 1-second resolution of RADIUS,
        #  and the possibility that the time on the NAS may be off.
        #
        #  The start time is: NOW - delay - session_length
        #

    #	update request {
    #	  	&FreeRADIUS-Acct-Session-Start-Time = "%{expr: %l - %{%{Acct-Session-Time}:-0} - %{%{Acct-Delay-Time}:-0}}"
    #	}


        #
        #  Ensure that we have a semi-unique identifier for every
        #  request, and many NAS boxes are broken.
        acct_unique

        #
        #  Look for IPASS-style 'realm/', and if not found, look for
        #  '@realm', and decide whether or not to proxy, based on
        #  that.
        #
        #  Accounting requests are generally proxied to the same
        #  home server as authentication requests.
    #	IPASS
        suffix
    #	ntdomain

        #
        #  Read the 'acct_users' file
        files
    }

    #
    #  Accounting.  Log the accounting data.
    #
    accounting {
        #  Update accounting packet by adding the CUI attribute
        #  recorded from the corresponding Access-Accept
        #  use it only if your NAS boxes do not support CUI themselves
    #	cui

        #
        #  Create a 'detail'ed log of the packets.
        #  Note that accounting requests which are proxied
        #  are also logged in the detail file.
        detail
    #	daily

        #  Update the wtmp file
        #
        #  If you don't use "radlast" (becoming obsolete and no longer
        #  available on all systems), you can delete this line.
    #	unix

        #
        #  For Simultaneous-Use tracking.
        #
        #  Due to packet losses in the network, the data here
        #  may be incorrect.  There is little we can do about it.
    #	radutmp
    #	sradutmp

        #
        #  Return an address to the IP Pool when we see a stop record.
        #
        #  Ensure that &control:Pool-Name is set to determine which
        #  pool of IPs are used.
    #	sqlippool

        #
        #  Log traffic to an SQL database.
        #
        #  See "Accounting queries" in mods-available/sql
        -sql

        #
        #  If you receive stop packets with zero session length,
        #  they will NOT be logged in the database.  The SQL module
        #  will print a message (only in debugging mode), and will
        #  return "noop".
        #
        #  You can ignore these packets by uncommenting the following
        #  three lines.  Otherwise, the server will not respond to the
        #  accounting request, and the NAS will retransmit.
        #
    #	if (noop) {
    #		ok
    #	}

        #  Cisco VoIP specific bulk accounting
    #	pgsql-voip

        # For Exec-Program and Exec-Program-Wait
        exec

        #  Filter attributes from the accounting response.
        attr_filter.accounting_response

        #
        #  See "Autz-Type Status-Server" for how this works.
        #
    #	Acct-Type Status-Server {
    #
    #	}
        python3
    }
}